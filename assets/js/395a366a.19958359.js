"use strict";(self.webpackChunkk_8_s_god=self.webpackChunkk_8_s_god||[]).push([[9009],{28453:(t,e,n)=>{n.d(e,{R:()=>l,x:()=>c});var o=n(96540);const r={},s=o.createContext(r);function l(t){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function c(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:l(t.components),o.createElement(s.Provider,{value:e},t.children)}},39613:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>i});const o=JSON.parse('{"id":"pgsql/storage/xlog","title":"xlog","description":"- \u5168\u5c40\u53d8\u91cf","source":"@site/docs/pgsql/storage/xlog.md","sourceDirName":"pgsql/storage","slug":"/pgsql/storage/xlog","permalink":"/blog/docs/pgsql/storage/xlog","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/pgsql/storage/xlog.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"pg\u5171\u4eab\u5185\u5b58","permalink":"/blog/docs/pgsql/storage/pg\u5171\u4eab\u5185\u5b58"},"next":{"title":"\u5e72\u8d27  PostgreSQL\u6570\u636e\u8868\u6587\u4ef6\u5e95\u5c42\u7ed3\u6784\u5e03\u5c40\u5206\u6790 - \u77e5\u4e4e","permalink":"/blog/docs/pgsql/storage/\u5e72\u8d27  PostgreSQL\u6570\u636e\u8868\u6587\u4ef6\u5e95\u5c42\u7ed3\u6784\u5e03\u5c40\u5206\u6790 - \u77e5\u4e4e"}}');var r=n(74848),s=n(28453);const l={},c="xlog",a={},i=[{value:"xlog\u5199\u5165\u6d41\u7a0b",id:"xlog\u5199\u5165\u6d41\u7a0b",level:2}];function g(t){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"xlog",children:"xlog"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"\u5168\u5c40\u53d8\u91cf"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:"static XLogCtlData *XLogCtl = NULL;\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:"typedef uint64 XLogRecPtr;\n\ntypedef struct XLogwrtRqst\n{\n\tXLogRecPtr\tWrite;\t\t\t/* last byte + 1 to write out */\n\tXLogRecPtr\tFlush;\t\t\t/* last byte + 1 to flush */\n} XLogwrtRqst;\n\ntypedef struct XLogwrtResult\n{\n\tXLogRecPtr\tWrite;\t\t\t/* last byte + 1 written out */\n\tXLogRecPtr\tFlush;\t\t\t/* last byte + 1 flushed */\n} XLogwrtResult;\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"XLogCtlData"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:"typedef struct XLogCtlData\n{\n\tXLogCtlInsert Insert;\n\n\t/* Protected by info_lck: */\n\tXLogwrtRqst LogwrtRqst;\n\tXLogRecPtr\tRedoRecPtr;\t\t/* a recent copy of Insert->RedoRecPtr */\n\tFullTransactionId ckptFullXid;\t/* nextXid of latest checkpoint */\n\tXLogRecPtr\tasyncXactLSN;\t/* LSN of newest async commit/abort */\n\tXLogRecPtr\treplicationSlotMinLSN;\t/* oldest LSN needed by any slot */\n\n\tXLogSegNo\tlastRemovedSegNo;\t/* latest removed/recycled XLOG segment */\n\n\t/* Fake LSN counter, for unlogged relations. Protected by ulsn_lck. */\n\tXLogRecPtr\tunloggedLSN;\n\tslock_t\t\tulsn_lck;\n\n\t/* Time and LSN of last xlog segment switch. Protected by WALWriteLock. */\n\tpg_time_t\tlastSegSwitchTime;\n\tXLogRecPtr\tlastSegSwitchLSN;\n\n\t/*\n\t * Protected by info_lck and WALWriteLock (you must hold either lock to\n\t * read it, but both to update)\n\t */\n\tXLogwrtResult LogwrtResult;\n\tXLogRecPtr\tInitializedUpTo;\n\n\tchar\t   *pages;\t\t\t/* buffers for unwritten XLOG pages */\n\tXLogRecPtr *xlblocks;\t\t/* 1st byte ptr-s + XLOG_BLCKSZ */\n\tint\t\t\tXLogCacheBlck;\t/* highest allocated xlog buffer index */\n\n\tTimeLineID\tInsertTimeLineID;\n\tTimeLineID\tPrevTimeLineID;\n\n\tRecoveryState SharedRecoveryState;\n\n\tbool\t\tInstallXLogFileSegmentActive;\n\n\tbool\t\tWalWriterSleeping;\n\n\tXLogRecPtr\tlastCheckPointRecPtr;\n\tXLogRecPtr\tlastCheckPointEndPtr;\n\tCheckPoint\tlastCheckPoint;\n\n\tXLogRecPtr\tlastFpwDisableRecPtr;\n\n\tslock_t\t\tinfo_lck;\t\t/* locks shared variables shown above */\n} XLogCtlData;\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:"typedef struct XLogCtlInsert\n{\n\tslock_t\t\tinsertpos_lck;\t/* protects CurrBytePos and PrevBytePos */\n\tuint64\t\tCurrBytePos;\n\tuint64\t\tPrevBytePos;\n\n\tchar\t\tpad[PG_CACHE_LINE_SIZE];\n\n\tXLogRecPtr\tRedoRecPtr;\t\t/* current redo point for insertions */\n\tbool\t\tforcePageWrites;\t/* forcing full-page writes for PITR? */\n\tbool\t\tfullPageWrites;\n\n\tint\t\t\trunningBackups;\n\tXLogRecPtr\tlastBackupStart;\n\tWALInsertLockPadded *WALInsertLocks;\n} XLogCtlInsert;\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"XLogRecord"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:"typedef struct XLogRecord\n{\n\tuint32\t\txl_tot_len;\t\t/* total len of entire record */\n\tTransactionId xl_xid;\t\t/* xact id */\n\tXLogRecPtr\txl_prev;\t\t/* ptr to previous record in log */\n\tuint8\t\txl_info;\t\t/* flag bits, see below */\n\tRmgrId\t\txl_rmid;\t\t/* resource manager for this record */\n\t/* 2 bytes of padding here, initialize to zero */\n\tpg_crc32c\txl_crc;\t\t\t/* CRC for this record */\n\n\t/* XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding */\n\n} XLogRecord;\n"})}),"\n",(0,r.jsx)(e.h2,{id:"xlog\u5199\u5165\u6d41\u7a0b",children:"xlog\u5199\u5165\u6d41\u7a0b"}),"\n",(0,r.jsx)(e.mermaid,{value:"graph TB\nXLogFlush--\x3eXLogWrite--\x3epg_pwrite--\x3ewrite"})]})}function d(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(g,{...t})}):g(t)}}}]);