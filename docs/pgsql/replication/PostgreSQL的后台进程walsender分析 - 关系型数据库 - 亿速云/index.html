<!doctype html>
<html lang="zh-CN" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-pgsql/replication/PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云 | 编程之路</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://github.com/blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://github.com/blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://github.com/blog/docs/pgsql/replication/PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云"><meta data-rh="true" property="og:locale" content="zh_CN"><meta data-rh="true" name="docusaurus_locale" content="zh-CN"><meta data-rh="true" name="docsearch:language" content="zh-CN"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云 | 编程之路"><meta data-rh="true" name="description" content="这篇文章主要介绍“PostgreSQL的后台进程walsender分析”，在日常操作中，相信很多人在PostgreSQL的后台进程walsender分析问题上存在疑惑，小编查阅了各式资料，整理出简单好用的操作方法，希望对大家解答”PostgreSQL的后台进程walsender分析”的疑惑有所帮助！接下来，请跟着小编一起来学习吧！"><meta data-rh="true" property="og:description" content="这篇文章主要介绍“PostgreSQL的后台进程walsender分析”，在日常操作中，相信很多人在PostgreSQL的后台进程walsender分析问题上存在疑惑，小编查阅了各式资料，整理出简单好用的操作方法，希望对大家解答”PostgreSQL的后台进程walsender分析”的疑惑有所帮助！接下来，请跟着小编一起来学习吧！"><link data-rh="true" rel="icon" href="/blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://github.com/blog/docs/pgsql/replication/PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云"><link data-rh="true" rel="alternate" href="https://github.com/blog/docs/pgsql/replication/PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://github.com/blog/docs/pgsql/replication/PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云" hreflang="x-default"><link rel="stylesheet" href="/blog/assets/css/styles.38da314a.css">
<script src="/blog/assets/js/runtime~main.7a87f3fa.js" defer="defer"></script>
<script src="/blog/assets/js/main.5655fcd3.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/blog/"></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/docs/intro">k8s修仙指南</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/growdu/k8s_god" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/blog/docs/intro">编程之路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/blog/docs/how_to_learn_program">&lt;center&gt;如何学习编程&lt;/center&gt;</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/alg/B-树如何使查询更快">alg</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/blog/docs/base/">&lt;center&gt;写在前面&lt;/center&gt;</a><button aria-label="展开侧边栏分类 &#x27;&lt;center&gt;写在前面&lt;/center&gt;&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/chatgpt/chatgpt使用">chatgpt</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/cluster/C语言实现分布式自增有序的唯一ID生成算法-snowflake算法">cluster</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/code/JavaScript-work/">code</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/db/postgresql/part1">db</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/docker/docker_communication_with_host">docker</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/dpdk/day1">dpdk</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/edit/docusaurus自定义渲染内容">edit</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/es/Search UI with Elasticsearch  Elastic docs --- 使用 Elasticsearch 的搜索用户界面 弹性文档">es</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/faq/faq汇总">faq</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/blog/docs/go_web/">rest api</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/language/C语言内存使用血与泪教训">language</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/linux/centos搭建离线仓库">linux</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/mail/email编程">mail</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/network/C语言网络编程库选择">network</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/openguass/opengauss dcf搭建 - 墨天轮">openguass</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/blog/docs/page/">&lt;center&gt;说明&lt;/center&gt;</a><button aria-label="展开侧边栏分类 &#x27;&lt;center&gt;说明&lt;/center&gt;&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/blog/docs/pgsql/PostgreSQL 时间线解析">pgsql</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/PostgreSQL 时间线解析">PostgreSQL 时间线解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/Postgres中postmaster代码解析(--boot和--single)">Postgres中postmaster代码解析(--boot和--single)</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/checkpoint机制浅析">checkpoint机制浅析</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/debug/code-server调试postgresql">debug</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/executor/PostgreSQL的insert语句执行过程分析 - 墨天轮">executor</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/extension/pgsql扩展">extension</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/ha/repmgr实现原理">ha</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/insert_data">insert data</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/kernel/Postgresql触发器详解">kernel</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/pg_command/initdb">pg_command</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/pg_complie_and_run">pg编译运行</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/pg_io_调优">pg_io_调优</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/pg_replication">pg_replication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/pgsql_main_structure">pgsql架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/pg源码对象管理">pg源码对象管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/postgresql——流复制和wal日志（八）">postgresql——流复制和wal日志（八）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/postgresql启动流程">postgresql 启动流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/postgresql基操">postgresql基本操作与基本对象</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/postgresql源码编译">postgresql 源码编译</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/process/BgWriter">process</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/blog/docs/pgsql/replication/PostgreSQL 同步流复制原理和代码浅析-阿里云开发者社区">replication</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/PostgreSQL 同步流复制原理和代码浅析-阿里云开发者社区">PostgreSQL 同步流复制原理和代码浅析-阿里云开发者社区</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/PostgreSQL复制槽实操">PostgreSQL复制槽实操</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/PostgreSQL数据库复制——后台一等公民进程WalReceiver&amp;startup交互_postgressql walreceive线程_肥叔菌的博客-CSDN博客">PostgreSQL数据库复制——后台一等公民进程WalReceiver&amp;startup交互_postgressql walreceive线程_肥叔菌的博客-CSDN博客</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/blog/docs/pgsql/replication/PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云">PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/Postgresql存储、索引及系统优化、主备切换">0 Postgresql存储、索引及系统优化、主备切换</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/docker搭建Postgresql主备集群">docker搭建Postgresql主备集群</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/pg_logic_decode">pg_logical_decode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/pg_replication_keepalive">流复制心跳超时问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/pg_slot">pg_slot</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/pg_walreceiver">pg_walreceiver</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/pg_walsender">pg_walsender</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/postgresql startup处理 - postgresql内核分析 - SegmentFault 思否">postgresql startup处理 - postgresql内核分析 - SegmentFault 思否</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/postgresql流复制同异步分析">postgresql流复制同异步分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/replication/详解完整恢复及基于时间点的恢复">详解完整恢复及基于时间点的恢复</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/repmgr/pgsql_repmgr">repmgr</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/sql_test">sql_test</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/stats/">stats</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/blog/docs/pgsql/storage/PosgreSQL FSM文件解析 – 蛋挞">storage</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/wal机制浅析">wal机制浅析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/blog/docs/pgsql/数据库崩溃恢复">数据库崩溃恢复</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/programmer_self_cultivation/linux生成coredump">programmer_self_cultivation</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/protocol/fib表">protocol</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/road/左耳朵耗子的话——关于技术的一些思考">road</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/storage/nfs详解">storage</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/blog/docs/tools/">readme</a><button aria-label="展开侧边栏分类 &#x27;readme&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/video_work/video">video_work</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/vpp/cdu_nxp2160_ptp1588v2实现方案">vpp</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/blog/docs/vue/5种回到顶部的写法从实现到增强 - 小火柴的蓝色理想 - 博客园">vue</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">pgsql</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">replication</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云</h1></header><p>这篇文章主要介绍“PostgreSQL的后台进程walsender分析”，在日常操作中，相信很多人在PostgreSQL的后台进程walsender分析问题上存在疑惑，小编查阅了各式资料，整理出简单好用的操作方法，希望对大家解答”PostgreSQL的后台进程walsender分析”的疑惑有所帮助！接下来，请跟着小编一起来学习吧！</p>
<p>该进程实质上是streaming replication环境中master节点上普通的backend进程,在standby节点启动时,standby节点向master发送连接请求,master节点的postmaster进程接收到请求后,启动该进程与standby节点的walreceiver进程建立通讯连接,用于传输WAL Record.<br>
<!-- -->walsender启动后,使用gdb跟踪此进程,其调用栈如下:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) bt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#0  0x00007fb6e6390903 in __epoll_wait_nocancel () from /lib64/libc.so.6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#1  0x000000000088e668 in WaitEventSetWaitBlock (set=0x10ac808, cur_timeout=29999, occurred_events=0x7ffd634441b0, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nevents=1) at latch.c:1048</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#2  0x000000000088e543 in WaitEventSetWait (set=0x10ac808, timeout=29999, occurred_events=0x7ffd634441b0, nevents=1, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wait_event_info=83886092) at latch.c:1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#3  0x000000000088dcec in WaitLatchOrSocket (latch=0x7fb6dcbfc4d4, wakeEvents=27, sock=10, timeout=29999, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wait_event_info=83886092) at latch.c:385</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#4  0x000000000085405b in WalSndLoop (send_data=0x8547fe &lt;XLogSendPhysical&gt;) at walsender.c:2229</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#5  0x0000000000851c93 in StartReplication (cmd=0x10ab750) at walsender.c:684</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#6  0x00000000008532f0 in exec_replication_command (cmd_string=0x101dd78 &quot;START_REPLICATION 0/5D000000 TIMELINE 16&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    at walsender.c:1539</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#7  0x00000000008c0170 in PostgresMain (argc=1, argv=0x1049cb8, dbname=0x1049ba8 &quot;&quot;, username=0x1049b80 &quot;replicator&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    at postgres.c:4178</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#8  0x000000000081e06c in BackendRun (port=0x103fb50) at postmaster.c:4361</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#9  0x000000000081d7df in BackendStartup (port=0x103fb50) at postmaster.c:4033</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#10 0x0000000000819bd9 in ServerLoop () at postmaster.c:1706</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#11 0x000000000081948f in PostmasterMain (argc=1, argv=0x1018a50) at postmaster.c:1379</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#12 0x0000000000742931 in main (argc=1, argv=0x1018a50) at main.c:228</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>本节首先介绍调用栈中PostgresMain函数.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="一数据结构">一、数据结构<a href="#一数据结构" class="hash-link" aria-label="一、数据结构的直接链接" title="一、数据结构的直接链接">​</a></h4>
<p><strong>StringInfo</strong><br>
<!-- -->StringInfoData结构体保存关于扩展字符串的相关信息.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/*-------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * StringInfoData holds information about an extensible string.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * StringInfoData结构体保存关于扩展字符串的相关信息.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      data    is the current buffer for the string (allocated with palloc).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      data    通过palloc分配的字符串缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      len     is the current string length.  There is guaranteed to be</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              a terminating &#x27;\0&#x27; at data[len], although this is not very</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              useful when the string holds binary data rather than text.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      len     是当前字符串的长度.保证以ASCII 0(\0)结束(data[len] = &#x27;\0&#x27;).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              虽然如果存储的是二进制数据而不是文本时不太好使.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      maxlen  is the allocated size in bytes of &#x27;data&#x27;, i.e. the maximum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              string size (including the terminating &#x27;\0&#x27; char) that we can</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              currently store in &#x27;data&#x27; without having to reallocate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              more space.  We must always have maxlen &gt; len.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      maxlen  以字节为单位已分配的&#x27;data&#x27;的大小,限定了最大的字符串大小(包括结尾的ASCII 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              小于此尺寸的数据可以直接存储而无需重新分配.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      cursor  is initialized to zero by makeStringInfo or initStringInfo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              but is not otherwise touched by the stringinfo.c routines.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              Some routines use it to scan through a StringInfo.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      cursor  通过makeStringInfo或initStringInfo初始化为0,但不受stringinfo.c例程的影响.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              某些例程使用该字段扫描StringInfo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *-------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct StringInfoData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char       *data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int         len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int         maxlen;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int         cursor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} StringInfoData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef StringInfoData *StringInfo;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="二源码解读">二、源码解读<a href="#二源码解读" class="hash-link" aria-label="二、源码解读的直接链接" title="二、源码解读的直接链接">​</a></h4>
<p><strong>PostgresMain</strong><br>
<!-- -->后台进程postgres的主循环入口 — 所有的交互式或其他形式的后台进程在这里启动.<br>
<!-- -->其主要逻辑如下:<br>
<!-- -->1.初始化相关变量<br>
<!-- -->2.初始化进程信息,设置进程状态,初始化GUC参数<br>
<!-- -->3.解析命令行参数并作相关校验<br>
<!-- -->4.如为walsender进程,则调用WalSndSignals初始化,否则执行其他信号初始化<br>
<!-- -->5.初始化BlockSig/UnBlockSig/StartupBlockSig<br>
<!-- -->6.非Postmaster,则检查数据库路径/切换路径/创建锁定文件等操作<br>
<!-- -->7.调用BaseInit执行基本的初始化<br>
<!-- -->8.调用InitProcess/InitPostgres初始化进程<br>
<!-- -->9.重置内存上下文,处理加载库和前后台消息交互等<br>
<!-- -->10.初始化内存上下文<br>
<!-- -->11.进入主循环<br>
<!-- -->11.1切换至MessageContext上下文<br>
<!-- -->11.2初始化输入的消息<br>
<!-- -->11.3给客户端发送可以执行查询等消息<br>
<!-- -->11.4读取命令<br>
<!-- -->11.5根据命令类型执行相关操作</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* ----------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * PostgresMain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     postgres main loop -- all backends, interactive or otherwise start here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *     postgres主循环 -- 所有的交互式或其他形式的后台进程在这里启动 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * argc/argv are the command line arguments to be used.  (When being forked</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * by the postmaster, these are not the original argv array of the process.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * dbname is the name of the database to connect to, or NULL if the database</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * name should be extracted from the command line arguments or defaulted.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * username is the PostgreSQL user name to be used for the session.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * argc/argv是命令行参数(postmaster fork进程时,不存在原有的进程argv数组).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * dbname是连接的数据库名称,如需要从命令行参数中解析或者为默认的数据库名称,则为NULL.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * username是PostgreSQL会话的用户名.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * ----------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    argc/argv-Main函数的输入参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dbname-数据库名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    username-用户名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    无</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PostgresMain(int argc, char *argv[],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             const char *dbname,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             const char *username)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int         firstchar;//临时变量，读取输入的Command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringInfoData input_message;//字符串增强结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sigjmp_buf  local_sigjmp_buf;//系统变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile bool send_ready_for_query = true;//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool        disable_idle_in_transaction_timeout = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Initialize startup process environment if necessary. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如需要,初始化启动进程环境</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!IsUnderPostmaster//未初始化？initialized for the bootstrap/standalone case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitStandaloneProcess(argv[0]);//初始化进程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SetProcessingMode(InitProcessing);//设置进程状态为InitProcessing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Set default values for command-line options.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 设置命令行选项默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitializeGUCOptions();//初始化GUC参数，GUC=Grand Unified Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Parse command-line options.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 解析命令行选项</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    process_postgres_switches(argc, argv, PGC_POSTMASTER, &amp;dbname);//解析输入参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Must have gotten a database name, or have a default (the username) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //必须包含数据库名称或者存在默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (dbname == NULL)//输入的dbname为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dbname = username;//设置为用户名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dbname == NULL)//如仍为空，报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ereport(FATAL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (errcode(ERRCODE_INVALID_PARAMETER_VALUE),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     errmsg(&quot;%s: no database nor user name specified&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            progname)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Acquire configuration parameters, unless inherited from postmaster */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //请求配置参数,除非从postmaster中继承</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!SelectConfigFiles(userDoption, progname))//读取配置文件conf/hba文件&amp;定位数据目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            proc_exit(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Set up signal handlers and masks.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 配置信号handlers和masks.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Note that postmaster blocked all signals before forking child process,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * so there is no race condition whereby we might receive a signal before</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * we have set up the handler.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 注意在fork子进程前postmaster已阻塞了所有信号,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   因此就算接收到信号,但在完成配置handler前不会存在条件争用.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Also note: it&#x27;s best not to use any signals that are SIG_IGNored in the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * postmaster.  If such a signal arrives before we are able to change the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * handler to non-SIG_IGN, it&#x27;ll get dropped.  Instead, make a dummy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * handler in the postmaster to reserve the signal. (Of course, this isn&#x27;t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * an issue for signals that are locally generated, such as SIGALRM and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * SIGPIPE.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 同时注意:最好不要使用在postmaster中标记为SIG_IGNored的信号.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果在改变处理器为non-SIG_IGN前,接收到这样的信号,会被清除.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 相反,可以在postmaster中创建dummy handler来保留这样的信号.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * (当然,对于本地产生的信号,比如SIGALRM和SIGPIPE,这不会是问题)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (am_walsender)//wal sender进程？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WalSndSignals();//如果是，则调用WalSndSignals</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else//不是wal sender进程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //设置标记,读取配置文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGHUP, PostgresSigHupHandler);    /* set flag to read config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                     * file */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //中断信号处理器(中断当前查询)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGINT, StatementCancelHandler);   /* cancel current query */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //终止当前查询并退出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGTERM, die); /* cancel current query and exit */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * In a standalone backend, SIGQUIT can be generated from the keyboard</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * easily, while SIGTERM cannot, so we make both signals do die()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * rather than quickdie().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 在standalone进程,SIGQUIT可很容易的通过键盘生成,而SIGTERM则不好生成,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *   因此让这两个信号执行die()而不是quickdie().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //bool IsUnderPostmaster = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //悲催时刻,执行quickdie()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pqsignal(SIGQUIT, quickdie);    /* hard crash time */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //执行die()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pqsignal(SIGQUIT, die); /* cancel current query and exit */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //建立SIGALRM处理器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitializeTimeouts();   /* establishes SIGALRM handler */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Ignore failure to write to frontend. Note: if frontend closes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * connection, we will notice it and exit cleanly when control next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * returns to outer loop.  This seems safer than forcing exit in the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * midst of output during who-knows-what operation...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 忽略写入前端的错误.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 注意:如果前端关闭了连接,会通知并在空中下一次返回给外层循环时退出.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 这看起来会比在who-knows-what操作期间强制退出安全一些.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGPIPE, SIG_IGN);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGUSR1, procsignal_sigusr1_handler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGUSR2, SIG_IGN);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGFPE, FloatExceptionHandler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Reset some signals that are accepted by postmaster but not by</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * backend</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 重置一些postmaster接收而后台进程不会接收的信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //在某些平台上,system()需要这个信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pqsignal(SIGCHLD, SIG_DFL); /* system() requires this on some</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                     * platforms */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //初始化BlockSig/UnBlockSig/StartupBlockSig</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pqinitmask();//Initialize BlockSig, UnBlockSig, and StartupBlockSig.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* We allow SIGQUIT (quickdie) at all times */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //放开SIGQUIT(quickdie)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sigdelset(&amp;BlockSig, SIGQUIT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //除了SIGQUIT,阻塞其他</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PG_SETMASK(&amp;BlockSig);      /* block everything except SIGQUIT */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Validate we have been given a reasonable-looking DataDir (if under</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * postmaster, assume postmaster did this already).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 验证已给出了reasonable-looking DataDir </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (如在postmaster下,假定postmaster已完成了这个事情)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        checkDataDir();//确认数据库路径OK，使用stat命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Change into DataDir (if under postmaster, was done already) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //切换至数据库路径，使用chdir命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ChangeToDataDir();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Create lockfile for data directory.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建锁定文件，CreateLockFile(DIRECTORY_LOCK_FILE, amPostmaster, &quot;&quot;, true, DataDir);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CreateDataDirLockFile(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* read control file (error checking and contains config ) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //读取控制文件(错误检查和包含配置)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LocalProcessControlFile(false);//Read the control file, set respective GUCs.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Initialize MaxBackends (if under postmaster, was done already) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //从配置选项中初始化MaxBackends</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitializeMaxBackends();//Initialize MaxBackends value from config options.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Early initialization */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BaseInit();//执行基本的初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Create a per-backend PGPROC struct in shared memory, except in the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * this before we can use LWLocks (and in the EXEC_BACKEND case we already</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * had to do some stuff with LWLocks).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在共享内存中创建每个backend都有的PGPROC结构体,除了在SubPostmasterMain的EXEC_BACKEND情况.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在可以使用LWLocks前必须执行该操作.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * (在EXEC_BACKEND中,已使用了LWLocks执行这个场景)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// initialize a per-process data structure for this backend</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef EXEC_BACKEND</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitProcess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    InitProcess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* We need to allow SIGINT, etc during the initial transaction */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在初始化事务期间需要允许SIGINT等等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PG_SETMASK(&amp;UnBlockSig);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * General initialization.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 常规的初始化.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * NOTE: if you are tempted to add code in this vicinity, consider putting</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * it inside InitPostgres() instead.  In particular, anything that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * involves database access should be there, not here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 注意:如果希望在此处添加代码,请考虑将其放入InitPostgres()中.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 特别的,任何涉及到数据库访问的内容都应该在InitPostgres中,而不是在这里.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    InitPostgres(dbname, InvalidOid, username, InvalidOid, NULL, false);//Initialize POSTGRES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * If the PostmasterContext is still around, recycle the space; we don&#x27;t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * need it anymore after InitPostgres completes.  Note this does not trash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * *MyProcPort, because ConnCreate() allocated that space with malloc()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * ... else we&#x27;d need to copy the Port data first.  Also, subsidiary data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * such as the username isn&#x27;t lost either; see ProcessStartupPacket().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果PostmasterContext仍然存在,回收空间;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在InitPostgres完成后,我们不再需要这些空间.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 注意:这个操作不会回收*MyProcPort,因为ConnCreate()分配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (PostmasterContext)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MemoryContextDelete(PostmasterContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PostmasterContext = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //完成初始化后，设置进程模式为NormalProcessing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SetProcessingMode(NormalProcessing);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Now all GUC states are fully set up.  Report them to client if</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * appropriate.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Report GUC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BeginReportingGUCOptions();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Also set up handler to log session end; we have to wait till now to be</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * sure Log_disconnections has its final value.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //设置处理器,用于记录会话结束;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //等待直至确保Log_disconnections最终有值存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (IsUnderPostmaster &amp;&amp; Log_disconnections)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        on_proc_exit(log_disconnections, 0);//this function adds a callback function to the list of functions invoked by proc_exit()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Perform initialization specific to a WAL sender process. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //为WAL sender进程执行特别的初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (am_walsender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitWalSender();//初始化 WAL sender process</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * process any libraries that should be preloaded at backend start (this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * likewise can&#x27;t be done until GUC settings are complete)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 处理在后台进程启动时需要提前预装载的库(这个步骤在GUC配置完成后才能够执行)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    process_session_preload_libraries();//加载LIB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Send this backend&#x27;s cancellation info to the frontend.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 发送后端的取消信息到前台</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (whereToSendOutput == DestRemote)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringInfoData buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pq_beginmessage(&amp;buf, &#x27;K&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pq_sendint32(&amp;buf, (int32) MyProcPid);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pq_sendint32(&amp;buf, (int32) MyCancelKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pq_endmessage(&amp;buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Need not flush since ReadyForQuery will do it. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //不需要flush,因为ReadyForQuery会执行该操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Welcome banner for  case */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //standalone的欢迎信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (whereToSendOutput == DestDebug)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;\nPostgreSQL stand-alone backend %s\n&quot;, PG_VERSION);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Create the memory context we will use in the main loop.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建主循环中使用的内存上下文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * MessageContext is reset once per iteration of the main loop, ie, upon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * completion of processing of each command message from the client.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 主循环中,每一次迭代都会重置MessageContext,比如完成了每个命令的处理,已从客户端返回了信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //初始化内存上下文：MessageContext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MessageContext = AllocSetContextCreate(TopMemoryContext,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           &quot;MessageContext&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           ALLOCSET_DEFAULT_SIZES);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Create memory context and buffer used for RowDescription messages. As</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * SendRowDescriptionMessage(), via exec_describe_statement_message(), is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * frequently executed for ever single statement, we don&#x27;t want to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * allocate a separate buffer every time.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建RowDescription消息的内存上下文和缓存.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 每一条单独的语句执行时都会频繁的通过exec_describe_statement_message()函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   调用SendRowDescriptionMessage(),不希望在每次都分配单独的缓存.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //TODO 传输RowDescription messages？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    row_description_context = AllocSetContextCreate(TopMemoryContext,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                    &quot;RowDescriptionContext&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                    ALLOCSET_DEFAULT_SIZES);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MemoryContextSwitchTo(row_description_context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initStringInfo(&amp;row_description_buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MemoryContextSwitchTo(TopMemoryContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Remember stand-alone backend startup time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 记录stand-alone后台进程的启动时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PgStartTime = GetCurrentTimestamp();//记录启动时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * POSTGRES main processing loop begins here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * POSTGRES的主处理循环在这里开始</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * If an exception is encountered, processing resumes here so we abort the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * current transaction and start a new one.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果出现了异常,处理过程会在这里恢复因此PG可以回滚当前事务并启动新事务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * You might wonder why this isn&#x27;t coded as an infinite loop around a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * PG_TRY construct.  The reason is that this is the bottom of the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * exception stack, and so with PG_TRY there would be no exception handler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * in force at all during the CATCH part.  By leaving the outermost setjmp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * always active, we have at least some chance of recovering from an error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * during error recovery.  (If we get into an infinite loop thereby, it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * will soon be stopped by overflow of elog.c&#x27;s internal state stack.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 你可能会对这里不用PG_TRY构造一个无限循环感到困惑.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 理由是这是异常栈的底,因此在这里使用PG_TRY会导致在CATCH部分没有任何的异常处理器.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 通过让最外层的setjmp始终处于活动状态,我们起码有机会在错误恢复的错误中进行恢复.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * (如果进入了无线循环,会很快因为elog&#x27;s内部状态栈的溢出而停止)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Note that we use sigsetjmp(..., 1), so that this function&#x27;s signal mask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * (to wit, UnBlockSig) will be restored when longjmp&#x27;ing to here.  This</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * is essential in case we longjmp&#x27;d out of a signal handler on a platform</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * where that leaves the signal blocked.  It&#x27;s not redundant with the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * unblock in AbortTransaction() because the latter is only called if we</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * were inside a transaction.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 注意我们使用sigsetjmp(...,1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   以便该函数的信号mask(也就是说,UnBlockSig)在longjmp到这里的时候可以被还原.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在某个让信号继续阻塞的平台上通过longjmp跳出信号处理器时这样的处理是需要的.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 这与AbortTransaction()设置unblock并不多余因为如果我们在事务中保证只执行了一次.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (sigsetjmp(local_sigjmp_buf, 1) != 0)//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * NOTE: if you are tempted to add more code in this if-block,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * consider the high probability that it should be in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * AbortTransaction() instead.  The only stuff done directly here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * should be stuff that is guaranteed to apply *only* for outer-level</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * error recovery, such as adjusting the FE/BE protocol status.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 注意:如果你希望在if-block中添加代码,建议在AbortTransaction()中添加.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 直接添加在这里的唯一理由是可以应用对高层的错误恢复,比如调整FE/BE协议状态.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Since not using PG_TRY, must reset error stack by hand */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //不使用PG_TRY,必须重置错误栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        error_context_stack = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Prevent interrupts while cleaning up */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //清理时禁止中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HOLD_INTERRUPTS();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Forget any pending QueryCancel request, since we&#x27;re returning to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * the idle loop anyway, and cancel any active timeout requests.  (In</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * future we might want to allow some timeout requests to survive, but</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * at minimum it&#x27;d be necessary to do reschedule_timeouts(), in case</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * we got here because of a query cancel interrupting the SIGALRM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * interrupt handler.)  Note in particular that we must clear the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * statement and lock timeout indicators, to prevent any future plain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * query cancels from being misreported as timeouts in case we&#x27;re</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * forgetting a timeout cancel.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 废弃正在处理中QueryCancel请求,因为进程会返回到空闲循环中,同时取消所有活动的超时请求.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (在未来,我们可能希望运行某些超时请求仍然存活,但最起码有需要执行reschedule_timeouts(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *  在这种情况下到达这里的原因是查询取消是通过SIGALRM终端处理器中断的).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 注意特别的,必须清理语句和锁超时提示器,已避免在取消超时后后续的普通查询出现超时时没有报告.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        disable_all_timeouts(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        QueryCancelPending = false; /* second to avoid race condition */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stmt_timeout_active = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Not reading from the client anymore. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //不再从客户端读取信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DoingCommandRead = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Make sure libpq is in a good state */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //确保libq状态OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pq_comm_reset();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Report the error to the client and/or server log */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //向客户端和/或服务器日志报告错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EmitErrorReport();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Make sure debug_query_string gets reset before we possibly clobber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * the storage it points at.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 确保debug_query_string在可能破坏它所指向的存储之前重置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        debug_query_string = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Abort the current transaction in order to recover.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 取消当前事务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AbortCurrentTransaction();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (am_walsender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如为walsender,则执行清理工作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            WalSndErrorCleanup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //错误清理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PortalErrorCleanup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SPICleanup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * We can&#x27;t release replication slots inside AbortTransaction() as we</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * need to be able to start and abort transactions while having a slot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * acquired. But we never need to hold them across top level errors,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * so releasing here is fine. There&#x27;s another cleanup in ProcKill()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * ensuring we&#x27;ll correctly cleanup on FATAL errors as well.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 在AbortTransaction()中不能释放replication slots因为需要在持有slot时启动和回滚事务.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 但不限于在顶层出现错误时持有这些slots,因此在这里释放这些slots是OK的.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 这里在ProcKill()中存在另外一个清理确保我们可以在FATAL错误中正确的恢复.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (MyReplicationSlot != NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ReplicationSlotRelease();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* We also want to cleanup temporary slots on error. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //出现错误时,清理临时slots</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReplicationSlotCleanup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //重置JIT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        jit_reset_after_error();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Now return to normal top-level context and clear ErrorContext for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * next time.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 现在可以回到正常的顶层上下文中并为下次循环清理ErrorContext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MemoryContextSwitchTo(TopMemoryContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FlushErrorState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * If we were handling an extended-query-protocol message, initiate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * skip till next Sync.  This also causes us not to issue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * ReadyForQuery (until we get Sync).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果我们正在处理extended-query-protocol消息,启动跳过直至下次Sync.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 这同时会导致我们不会触发ReadyForQuery(直至接收到Sync)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (doing_extended_query_message)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ignore_till_sync = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* We don&#x27;t have a transaction command open anymore */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //不再有打开的事务命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        xact_started = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * If an error occurred while we were reading a message from the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * client, we have potentially lost track of where the previous</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * message ends and the next one begins.  Even though we have</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * otherwise recovered from the error, we cannot safely read any more</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * messages from the client, so there isn&#x27;t much we can do with the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * connection anymore.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果在读取客户端消息时出现错误,进程可能已经丢失了上一条消息结束和下一条消息开始的位置.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 虽然从错误中恢复了,但我们仍然不能安全的从客户端读取消息,因此我们对该连接已无能无力.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pq_is_reading_msg())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ereport(FATAL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (errcode(ERRCODE_PROTOCOL_VIOLATION),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     errmsg(&quot;terminating connection because protocol synchronization was lost&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Now we can allow interrupts again */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //允许中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RESUME_INTERRUPTS();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* We can now handle ereport(ERROR) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //现在可以处理ereport(ERROR)了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PG_exception_stack = &amp;local_sigjmp_buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ignore_till_sync)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //错误恢复后重新初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        send_ready_for_query = true;    /* initially, or after error */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Non-error queries loop here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 世界清净了...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;)//主循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * At top of loop, reset extended-query-message flag, so that any</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * errors encountered in &quot;idle&quot; state don&#x27;t provoke skip.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 在循环的最开始处,重置extended-query-message标记,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 以便在&quot;idle&quot;状态遇到错误时不会跳过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doing_extended_query_message = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Release storage left over from prior query cycle, and create a new</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * query input buffer in the cleared MessageContext.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 释放上一个查询周期中残余的存储空间,并在干净的MessageContext中创建新的查询输入缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MemoryContextSwitchTo(MessageContext);//切换至MessageContext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MemoryContextResetAndDeleteChildren(MessageContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initStringInfo(&amp;input_message);//初始化输入的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Also consider releasing our catalog snapshot if any, so that it&#x27;s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * not preventing advance of global xmin while we wait for the client.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 尝试释放catalog snapshot,以便在等待客户端返回时不会阻碍全局xmin的增加.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InvalidateCatalogSnapshotConditionally();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (1) If we&#x27;ve reached idle state, tell the frontend we&#x27;re ready for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * a new query.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (1) 如果是idle状态,告诉前台已准备接受新查询请求了.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Note: this includes fflush()&#x27;ing the last of the prior output.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 注意:这包含了fflush()&#x27;ing前一个输出的最后一个.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * This is also a good time to send collected statistics to the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * collector, and to update the PS stats display.  We avoid doing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * those every time through the message loop because it&#x27;d slow down</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * processing of batched messages, and because we don&#x27;t want to report</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * uncommitted updates (that confuses autovacuum).  The notification</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * processor wants a call too, if we are not in a transaction block.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 发送收集的统计信息到collector,正当其时!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 在每次消息循环时都发送统计信息是需要避免的,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *   因为我不希望报告未提交的更新(这会让autoacuum出现混乱).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果我们不在事务块中,那么通知处理器希望调用一次.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (send_ready_for_query)//I am ready!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (IsAbortedTransactionBlockState())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                set_ps_display(&quot;idle in transaction (aborted)&quot;, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pgstat_report_activity(STATE_IDLEINTRANSACTION_ABORTED, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Start the idle-in-transaction timer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (IdleInTransactionSessionTimeout &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    disable_idle_in_transaction_timeout = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enable_timeout_after(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         IdleInTransactionSessionTimeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (IsTransactionOrTransactionBlock())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                set_ps_display(&quot;idle in transaction&quot;, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pgstat_report_activity(STATE_IDLEINTRANSACTION, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Start the idle-in-transaction timer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (IdleInTransactionSessionTimeout &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    disable_idle_in_transaction_timeout = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enable_timeout_after(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         IdleInTransactionSessionTimeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ProcessCompletedNotifies();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pgstat_report_stat(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                set_ps_display(&quot;idle&quot;, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pgstat_report_activity(STATE_IDLE, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ReadyForQuery(whereToSendOutput);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            send_ready_for_query = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (2) Allow asynchronous signals to be executed immediately if they</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * come in while we are waiting for client input. (This must be</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * conditional since we don&#x27;t want, say, reads on behalf of COPY FROM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * STDIN doing the same thing.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (2) 如果异步信号在等待客户端输入时接收到,那么允许马上执行.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *     (这是有条件的,因为我们不希望或者说执行COPY FORM STDIN同样的动作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DoingCommandRead = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (3) read a command (loop blocks here)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (3) 读取命令(循环块)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstchar = ReadCommand(&amp;input_message);//读取命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (4) disable async signal conditions again.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (4) 再次禁用异步信号条件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Query cancel is supposed to be a no-op when there is no query in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * progress, so if a query cancel arrived while we were idle, just</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * reset QueryCancelPending. ProcessInterrupts() has that effect when</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * it&#x27;s called when DoingCommandRead is set, so check for interrupts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * before resetting DoingCommandRead.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 在处理过程中如无查询,那么取消查询被认为是no-op的,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *   因此如果在空闲状态下接收到查询取消信号,那么重置QueryCancelPending.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * ProcessInterrupts()函数在DoingCommandRead设置的时候调用会有类似的影响,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *   因此在重置DoingCommandRead前重新检查中断.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CHECK_FOR_INTERRUPTS();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DoingCommandRead = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (5) turn off the idle-in-transaction timeout</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (5) 关闭idle-in-transaction超时控制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (disable_idle_in_transaction_timeout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            disable_timeout(IDLE_IN_TRANSACTION_SESSION_TIMEOUT, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            disable_idle_in_transaction_timeout = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (6) check for any other interesting events that happened while we</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * slept.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (6) 在休眠时检查感兴趣的事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ConfigReloadPending)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigReloadPending = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ProcessConfigFile(PGC_SIGHUP);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (7) process the command.  But ignore it if we&#x27;re skipping till</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Sync.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * (7) 处理命令.但如果我们设置了ignore_till_sync则忽略之.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ignore_till_sync &amp;&amp; firstchar != EOF)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (firstchar)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;Q&#x27;:           /* simple query */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //--------- 简单查询</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    const char *query_string;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /* Set statement_timestamp() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //设置时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //SQL语句</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    query_string = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (am_walsender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //如为WAL sender,执行exec_replication_command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (!exec_replication_command(query_string))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            exec_simple_query(query_string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //普通的后台进程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        exec_simple_query(query_string);//执行SQL语句</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    send_ready_for_query = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;P&#x27;:           /* parse */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //---------- 解析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    const char *stmt_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    const char *query_string;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int         numParams;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Oid        *paramTypes = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    forbidden_in_wal_sender(firstchar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /* Set statement_timestamp() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    stmt_name = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    query_string = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    numParams = pq_getmsgint(&amp;input_message, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (numParams &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        int         i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        paramTypes = (Oid *) palloc(numParams * sizeof(Oid));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        for (i = 0; i &lt; numParams; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            paramTypes[i] = pq_getmsgint(&amp;input_message, 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //执行解析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    exec_parse_message(query_string, stmt_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       paramTypes, numParams);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;B&#x27;:           /* bind */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //------------- 绑定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                forbidden_in_wal_sender(firstchar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Set statement_timestamp() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * this message is complex enough that it seems best to put</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * the field extraction out-of-line</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * 该消息看起来比较复杂,看起来最好的做法是提取字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                exec_bind_message(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;E&#x27;:           /* execute */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //------------ 执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    const char *portal_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int         max_rows;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    forbidden_in_wal_sender(firstchar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /* Set statement_timestamp() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    portal_name = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    max_rows = pq_getmsgint(&amp;input_message, 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    exec_execute_message(portal_name, max_rows);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;F&#x27;:           /* fastpath function call */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //----------- 函数调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                forbidden_in_wal_sender(firstchar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Set statement_timestamp() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Report query to various monitoring facilities. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pgstat_report_activity(STATE_FASTPATH, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                set_ps_display(&quot;&lt;FASTPATH&gt;&quot;, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* start an xact for this function invocation */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                start_xact_command();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * Note: we may at this point be inside an aborted</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * transaction.  We can&#x27;t throw error for that until we&#x27;ve</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * finished reading the function-call message, so</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * HandleFunctionRequest() must check for it after doing so.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * Be careful not to do anything that assumes we&#x27;re inside a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * valid transaction here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* switch back to message context */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MemoryContextSwitchTo(MessageContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                HandleFunctionRequest(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* commit the function-invocation transaction */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                finish_xact_command();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                send_ready_for_query = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;C&#x27;:           /* close */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //---------- 关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int         close_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    const char *close_target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    forbidden_in_wal_sender(firstchar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    close_type = pq_getmsgbyte(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    close_target = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    switch (close_type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        case &#x27;S&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (close_target[0] != &#x27;\0&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                DropPreparedStatement(close_target, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                /* special-case the unnamed statement */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                drop_unnamed_stmt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        case &#x27;P&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                Portal      portal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                portal = GetPortalByName(close_target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                if (PortalIsValid(portal))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    PortalDrop(portal, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ereport(ERROR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    (errcode(ERRCODE_PROTOCOL_VIOLATION),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                     errmsg(&quot;invalid CLOSE message subtype %d&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            close_type)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (whereToSendOutput == DestRemote)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        pq_putemptymessage(&#x27;3&#x27;);    /* CloseComplete */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;D&#x27;:           /* describe */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //------------- 描述比如\d等命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int         describe_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    const char *describe_target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    forbidden_in_wal_sender(firstchar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /* Set statement_timestamp() (needed for xact) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    describe_type = pq_getmsgbyte(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    describe_target = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    switch (describe_type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        case &#x27;S&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            exec_describe_statement_message(describe_target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        case &#x27;P&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            exec_describe_portal_message(describe_target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ereport(ERROR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    (errcode(ERRCODE_PROTOCOL_VIOLATION),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                     errmsg(&quot;invalid DESCRIBE message subtype %d&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            describe_type)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;H&#x27;:           /* flush */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //--------- flush 刷新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (whereToSendOutput == DestRemote)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pq_flush();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;S&#x27;:           /* sync */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //---------- Sync 同步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                finish_xact_command();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                send_ready_for_query = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * &#x27;X&#x27; means that the frontend is closing down the socket. EOF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * means unexpected loss of frontend connection. Either way,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * perform normal shutdown.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;X&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case EOF:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * Reset whereToSendOutput to prevent ereport from attempting</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * to send any more messages to client.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (whereToSendOutput == DestRemote)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    whereToSendOutput = DestNone;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * NOTE: if you are tempted to add more code here, DON&#x27;T!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * Whatever you had in mind to do should be set up as an</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * on_proc_exit or on_shmem_exit callback, instead. Otherwise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * it will fail to be called during other backend-shutdown</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * scenarios.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                proc_exit(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;d&#x27;:           /* copy data */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;c&#x27;:           /* copy done */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &#x27;f&#x27;:           /* copy fail */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * Accept but ignore these messages, per protocol spec; we</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * probably got here because a COPY failed, and the frontend</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * is still sending data.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ereport(FATAL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        (errcode(ERRCODE_PROTOCOL_VIOLATION),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         errmsg(&quot;invalid frontend message type %d&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                firstchar)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }                           /* end of input-reading loop */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="三跟踪分析">三、跟踪分析<a href="#三跟踪分析" class="hash-link" aria-label="三、跟踪分析的直接链接" title="三、跟踪分析的直接链接">​</a></h4>
<p>在主节点上用gdb跟踪postmaster,在PostgresMain上设置断点后启动standby节点,进入断点</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[xdb@localhost ~]$ ps -ef|grep postgre</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xdb       1263     1  0 14:20 pts/0    00:00:00 /appdb/xdb/pg11.2/bin/postgres</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) b PostgresMain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1 at 0x8bf9df: file postgres.c, line 3660.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set follow-fork-mode child</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Continuing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[New process 1332]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Thread debugging using libthread_db enabled]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Switching to Thread 0x7fb3885d98c0 (LWP 1332)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1, PostgresMain (argc=1, argv=0x1aa4c78, dbname=0x1aa4b68 &quot;&quot;, username=0x1aa4b40 &quot;replicator&quot;) at postgres.c:3660</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3660        volatile bool send_ready_for_query = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1.初始化相关变量<br>
<!-- -->注意变量IsUnderPostmaster,如为T则表示该进程为postmaster的子进程</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p *argv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$1 = 0xc27715 &quot;postgres&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3661        bool        disable_idle_in_transaction_timeout = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3664        if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p IsUnderPostmaster</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$2 = true</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>2.初始化进程信息,设置进程状态,初始化GUC参数</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3667        SetProcessingMode(InitProcessing);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3672        if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p InitProcessing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$3 = InitProcessing</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>3.解析命令行参数并作相关校验</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3678        process_postgres_switches(argc, argv, PGC_POSTMASTER, &amp;dbname);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3681        if (dbname == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p dbname</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$4 = 0x1aa4b68 &quot;&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p username</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$5 = 0x1aa4b40 &quot;replicator&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3692        if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>4.如为walsender进程,则调用WalSndSignals初始化,否则执行其他信号初始化</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">3712        if (am_walsender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3713            WalSndSignals();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>5.初始化BlockSig/UnBlockSig/StartupBlockSig</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3751        pqinitmask();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3753        if (IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3756            sigdelset(&amp;BlockSig, SIGQUIT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3759        PG_SETMASK(&amp;BlockSig);      /* block everything except SIGQUIT */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>6.非子进程(仍为postmaster进程),则检查数据库路径/切换路径/创建锁定文件等操作</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">N/A</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>7.调用BaseInit执行基本的初始化</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">3785        BaseInit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>8.调用InitProcess/InitPostgres初始化进程</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">3797        InitProcess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3801        PG_SETMASK(&amp;UnBlockSig);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3810        InitPostgres(dbname, InvalidOid, username, InvalidOid, NULL, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>9.重置内存上下文,处理加载库和前后台消息交互等</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3819        if (PostmasterContext)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3821            MemoryContextDelete(PostmasterContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) P PostmasterContext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$6 = (MemoryContext) 0x1a78c60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) P *PostmasterContext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$7 = {type = T_AllocSetContext, isReset = false, allowInCritSection = false, methods = 0xc93260 &lt;AllocSetMethods&gt;, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  parent = 0x1a73aa0, firstchild = 0x1a9a700, prevchild = 0x1a7ac70, nextchild = 0x1a75ab0, name = 0xc2622a &quot;Postmaster&quot;, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ident = 0x0, reset_cbs = 0x0}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3822            PostmasterContext = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3825        SetProcessingMode(NormalProcessing);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3831        BeginReportingGUCOptions();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3837        if (IsUnderPostmaster &amp;&amp; Log_disconnections)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p Log_disconnections</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$8 = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$9 = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3841        if (am_walsender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3842            InitWalSender();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3848        process_session_preload_libraries();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3853        if (whereToSendOutput == DestRemote)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3857            pq_beginmessage(&amp;buf, &#x27;K&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3858            pq_sendint32(&amp;buf, (int32) MyProcPid);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3859            pq_sendint32(&amp;buf, (int32) MyCancelKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3860            pq_endmessage(&amp;buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3865        if (whereToSendOutput == DestDebug)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>10.初始化内存上下文</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3874        MessageContext = AllocSetContextCreate(TopMemoryContext,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3884        row_description_context = AllocSetContextCreate(TopMemoryContext,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3887        MemoryContextSwitchTo(row_description_context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3888        initStringInfo(&amp;row_description_buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3889        MemoryContextSwitchTo(TopMemoryContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3894        if (!IsUnderPostmaster)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3919        if (sigsetjmp(local_sigjmp_buf, 1) != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4027        PG_exception_stack = &amp;local_sigjmp_buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4029        if (!ignore_till_sync)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4030            send_ready_for_query = true;    /* initially, or after error */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>11.进入主循环<br>
<!-- -->11.1切换至MessageContext上下文</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4042            doing_extended_query_message = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4048            MemoryContextSwitchTo(MessageContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4049            MemoryContextResetAndDeleteChildren(MessageContext);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>11.2初始化输入的消息</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4051            initStringInfo(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4057            InvalidateCatalogSnapshotConditionally();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p input_message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$10 = {data = 0x1a78d78 &quot;&quot;, len = 0, maxlen = 1024, cursor = 0}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>11.3给客户端发送可以执行查询等消息</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4072            if (send_ready_for_query)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p send_ready_for_query</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$12 = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4074                if (IsAbortedTransactionBlockState())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4087                else if (IsTransactionOrTransactionBlock())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4102                    ProcessCompletedNotifies();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4103                    pgstat_report_stat(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4105                    set_ps_display(&quot;idle&quot;, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4106                    pgstat_report_activity(STATE_IDLE, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4109                ReadyForQuery(whereToSendOutput);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4110                send_ready_for_query = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>11.4读取命令<br>
<!-- -->命令是IDENTIFY_SYSTEM,判断系统标识是否OK<br>
<!-- -->firstchar -&gt; ASCII 81 —&gt; 字母’Q’</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4119            DoingCommandRead = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4124            firstchar = ReadCommand(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4135            CHECK_FOR_INTERRUPTS();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p input_message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$13 = {data = 0x1a78d78 &quot;IDENTIFY_SYSTEM&quot;, len = 16, maxlen = 1024, cursor = 0}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p firstchar</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$14 = 81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$15 = 81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4136            DoingCommandRead = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4141            if (disable_idle_in_transaction_timeout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4151            if (ConfigReloadPending)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4161            if (ignore_till_sync &amp;&amp; firstchar != EOF)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>11.5根据命令类型执行相关操作<br>
<!-- -->walsender —&gt; 执行exec_replication_command命令</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4164            switch (firstchar)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4171                        SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4173                        query_string = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4174                        pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p query_string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$16 = 0x1a78d78 &quot;IDENTIFY_SYSTEM&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4176                        if (am_walsender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4178                            if (!exec_replication_command(query_string))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4184                        send_ready_for_query = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4186                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4411        }                           /* end of input-reading loop */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>继续循环,接收命令,第二个命令是START_REPLICATION</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4124            firstchar = ReadCommand(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4135            CHECK_FOR_INTERRUPTS();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p input_message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$18 = {data = 0x1a78d78 &quot;START_REPLICATION 0/5D000000 TIMELINE 16&quot;, len = 41, maxlen = 1024, cursor = 0}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p firstchar</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$19 = 81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4164            switch (firstchar)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4171                        SetCurrentStatementStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4173                        query_string = pq_getmsgstring(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4174                        pq_getmsgend(&amp;input_message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4176                        if (am_walsender)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p query_string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$20 = 0x1a78d78 &quot;START_REPLICATION 0/5D000000 TIMELINE 16&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p input_message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$21 = {data = 0x1a78d78 &quot;START_REPLICATION 0/5D000000 TIMELINE 16&quot;, len = 41, maxlen = 1024, cursor = 41}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4178                            if (!exec_replication_command(query_string))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>开始执行复制,master节点使用psql连接数据库,执行sql语句,子进程会接收到相关信号,执行相关处理<br>
<!-- -->执行脚本</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[xdb@localhost ~]$ psql -d testdb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">psql (11.2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Type &quot;help&quot; for help.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">testdb=# drop table t1;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>子进程输出</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Program received signal SIGUSR1, User defined signal 1.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x00007fb38696c903 in __epoll_wait_nocancel () from /lib64/libc.so.6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Single stepping until exit from function __epoll_wait_nocancel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">which has no line number information.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">procsignal_sigusr1_handler (postgres_signal_arg=32766) at procsignal.c:262</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">262 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">263     int         save_errno = errno;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x00007fb3881eecd0 in __errno_location () from /lib64/libpthread.so.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Single stepping until exit from function __errno_location,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">which has no line number information.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">procsignal_sigusr1_handler (postgres_signal_arg=10) at procsignal.c:265</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">265     if (CheckProcSignal(PROCSIG_CATCHUP_INTERRUPT))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>DONE!</p>
<p>DEBUG退出gdb后,psql会话crash:(</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[xdb@localhost ~]$ psql -d testdb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">psql (11.2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Type &quot;help&quot; for help.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">testdb=# drop table t1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WARNING:  terminating connection because of crash of another server process</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DETAIL:  The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HINT:  In a moment you should be able to reconnect to the database and repeat your command.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server closed the connection unexpectedly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    This probably means the server terminated abnormally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    before or while processing the request.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The connection to the server was lost. Attempting reset: Failed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">!&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>到此，关于“PostgreSQL的后台进程walsender分析”的学习就结束了，希望能够解决大家的疑惑。理论与实践的搭配能更好的帮助大家学习，快去试试吧！若想继续学习更多相关知识，请继续关注亿速云网站，小编会继续努力为大家带来更多实用的文章！</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/pgsql/replication/PostgreSQL的后台进程walsender分析 - 关系型数据库 - 亿速云.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/docs/pgsql/replication/PostgreSQL数据库复制——后台一等公民进程WalReceiver&amp;startup交互_postgressql walreceive线程_肥叔菌的博客-CSDN博客"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">PostgreSQL数据库复制——后台一等公民进程WalReceiver&amp;startup交互_postgressql walreceive线程_肥叔菌的博客-CSDN博客</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/docs/pgsql/replication/Postgresql存储、索引及系统优化、主备切换"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">0 Postgresql存储、索引及系统优化、主备切换</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 growdu, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>